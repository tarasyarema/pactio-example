# [pact.io](https://pact.io) example

## Initial setup

- Only general requisites is `make`, but it can be skipped running
the commands directly.
- Run `git fetch --all --tags`
- `mage` to run pactflow commands more easly

### Consumer

1. Use LTS `node` version
2. Install deps
    ```bash
    cd consumer
    yarn i
    ```

### Producer

1. Setup all pact.io binaries (you can follow [these steps](https://github.com/pact-foundation/pact-go#installation))
2. Have `go` installed (any `>=1.14` should work)
3. Install modules (may be not needed as it will auto-fetch on first test)
    ```bash
    cd producer
    go mod download
    ```

## Development flow

### Setup

You will need a `.env` file with the following info

```
PACT_BROKER_BASE_URL={pactflow_broker_url}
PACT_BROKER_TOKEN={pactflow_api_token}
```

### Intro

The first thing to be noticed is that pact.io is consumer oriented, that is,
the consumer is _who_ defines the initial contract, as the following updates.
Hence, the producer has to implement based on that.

Each pact is formed by the following info:
- A local pact file generated by the consumer.
- Consumer
    - A version, e.g. `1.0.0`
    - A tag, e.g. `prod`
- Producer
    - A version, e.g. `1.0.0`
    - A tag, e.g. `prod`
    - Verification

Hence, once a consumer produces a new pact, it generates the following info
- The pact details (in terms of code)
- The consumer version
- The consumer tag/s

The producer then can target this pact and verify that for a given
producer version it satisfies the pact requirements of the pact for
the given consumer version and tag.

### Flow details

1. The consumer implements the consumption mechanism (function, handler, method,
    whatever, ...) e.g [cosnumer.ts](./consumer/consumer.ts) and wirtes the test for it
    e.g. [consumer.test.ts](./consumer/__tests__/consumer.test.ts).
2. The consumer run the tests and a pact is generated e.g. [here](./consumer/pacts).
3. Now the consumer may publish this pact to pacflow (using `mage publish` for instance)
4. The producer writes the initial implementation and writes the tests to conform
    the pact, e.g. [producer test](./producer/producer_test.go).
    When running the tests the producer updates the state of the current pact as
    revised and the pact is done.
5. The process iterates in the following flow:
    1. The consumer updates the code so that the pact may vary.
    2. The consumer creates a new revision of the pact via `mage consumerVersion`
    3. The producer may create also a new revision of the code to conform to the new
        pact definition.
    4. Iterate...

## Testing

From the root directory run `make test-local` to run all the test locally or
`make test` to run agains pactflow. Look at the terminal to see the output from pact.io.

Use the following tags to test various scenarios:
- `git checkout tags/v1.0.0-stable`: intial state, where the flow is ok, `v1.0.0` is deployed
- `git checkout tags/v2.0.0-break`: the consumer changes the contract and we see that the current state makes the producer tests fail, hence `v2.0.0` is not deployed
- `git checkout tags/v2.0.0-stable`: the producer changes the contracts so that version `v2.0.0` can be deployed
